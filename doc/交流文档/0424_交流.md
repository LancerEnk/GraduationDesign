# 0424_交流

**！！！当前任务！！！**

1. 真实地图数据处理
2. 可用的乘客和车辆位置选取

## 1 真实地图数据处理

**整体的流程**：

1. 把地图的原始数据导入数据库里
2. 在数据库里进行清洗和筛选
3. 筛选出的数据导出为json文件格式
4. 用脚本对json文件进行处理，得到最终的地图数据

**现在是停在第4步了，想通过交流获得**：

1. 确认目前能导出的json格式没问题
2. 4中提及的脚本，和脚本处理前后的`"old json file"`、`"new json file"`。

### 1.1 数据库中数据的正确性判断

cjz的相关手册中，提及了他用于筛选数据的sql语句和相应的结果。

因此，我使用该语句，在我的数据库中进行筛选，获取到了相似的结果：

```sql
-- 按照手册里的代码进行字段名称修改后，搜索：
select row_to_json(t)
from (select gid, code, name, round(cost::numeric,0) as cost, round(reverse_cost::numeric,0) as reverse_cost, start_x,start_y,end_x,end_y, oneway, source, target, ST_AsText(geom) as path from bjway where (start_x between 116.302165 and 116.363619) and (start_y between 39.927295 and 39.978418) and (code = 5113 or code =5114) order by gid) AS t;
-- 手册里说有600多条道路，我搜出来有695个结果，看起来差不多！
-- 另换了一个查询，查'皂君庙路'：
select row_to_json(t)
from (select gid, code, name, round(cost::numeric,0) as cost, round(reverse_cost::numeric,0) as reverse_cost, start_x as x1,start_y as y1,end_x as x2,end_y as y2, oneway, source, target, ST_AsText(geom) as path from bjway where (code = 5113 or code =5114) and name = '皂君庙路' order by gid) AS t;
-- 手册里查出来是8条结果，我查出来是10条结果，差不多！
```

考虑到他使用的可能是2017年前后的数据？但我使用的是2023年的数据。我的数据比较新，因此道路条数是有可能比他数据库中的道路条数多的。所以我认为我的数据库里的内容应该没什么问题。

### 1.2 json格式

随便摘取ways.json中的一条数据，和我现在能导出的数据库里的任意一条数据进行对比：

```json
// ways.json
{"gid":1,"class_id":106,"name":"广场西侧路","x1":116.38946,"y1":39.90599,"x2":116.38963,"y2":39.90173,"one_way":1,"source":36635,"target":23082,"path":"(116.38946 39.90599,116.38963 39.90173)"}

// 语句1，my json
{"gid":134559,"code":5114,"name":"皂君庙路","x1":116.32919,"y1":39.95628,"x2":116.32896,"y2":39.95840,"oneway":"F","source":21054,"target":21150,"path":"LINESTRING(116.32919029999998 39.956284299999986,116.32895729999997 39.95840219999998)"}
```

可以看到，现在的不一致主要出现在很基础的格式问题：`code和class_id`、`oneway的值`、`path有无'LINESTRING'和经纬度的精度`是不同的，其余都一样。

1. **通过我的观察，code和class_id的关系如下**：
    (1). code = a 时，道路类型是x；道路类型是x时，其class_id是b。
    (2). 因此，code和class_id实际上可以进行转换。
2. **oneway的值事实上也是有对应关系的**：

    ```txt
    我的数据库一共224282条数据
    oneway = 'T'  |  'reversed'  |  '2'  |  逆向  |  但实际上在我获取的shp文件数据里，这种逆向单行道已经很少了(25条数据)，几乎没有
    oneway = 'F'  |  'yes'       |  '1'  |  正向  |  有74353条数据
    oneway = 'B'  |  'unknown'   |  '0'  |  双向  |  有149904条数据
    ```

    (1). 这个也能操作，可以在当前的表里新建一列`one_way`，然后根据`oneway`的不同给`one_way`赋不同的值。这个已经在我的测试表`test`中实现了。这说明完全可以通过同样的操作，在现有道路数据的表中直接把`'T'、'F'、'B'`修改成`'0'、'1'、'2'`。
    (2). 但是有没有必要新建`one_way`列？这个得根据处理`json`的脚本看。
3. **path有无'LINESTRING'和经纬度的精度**
    (1). 这个得根据处理`json`的脚本看。

### 1.3 脚本的作用？

脚本这里，我存在如下的问题：

1. **我不知道脚本具体能做什么事情**？
2. **需要根据脚本来确定，我是否还需要对数据库里的东西进行更多的操作**？
    * 如生成新的列，导出新的列。
    * 如在数据库里就对数据进行再加工，从而一次性导出适配脚本的json文件。

## 2 可用的乘客和车辆位置选取

1. goodP.txt：（一共9组）
2. badP.txt：（有代表性的，一共4组，其主要存在三类问题）
    * vehicle：timeout
        * 感觉可能是因为vehicle的位置太偏了？
        * 但不确定是不是这个原因...
    * passenger：out of gas
        * 至今不知道是为啥
        * 上一次解决的方法：玄学
    * vehicle：geohash为空，即寻路为空
        * 就...重新楞选点
        * 但也没什么太好的选择方法了

选取的点的特性。

1. 可以把点位放在[geohash网页](https://geohash.softeng.co/)中，先在这个网页里大概确定一下点的位置和其所处道路的方向。
    (1)位置观察：保证点不偏离出地图
    (2)道路方向：方便选取本轮中车乘的其他位置，不至于寻不到路

### 2.1 根据测试方法的不同，来反限制选取的点的特性？

假设一共有n轮点，当前是第i轮（1<=i<=n）。

每轮运行，需要关注的两个寻路过程为PickUp()和manageToEnd()。

* PickUp()：车辆位置 -> 乘客起点
* manageToEnd()：乘客起点 -> 乘客终点

#### 如果车and乘可以瞬移

则实际上，第i-1轮的车乘位置与第i轮的车乘位置可以完全不同。

即此种情况完全对选点无限制。

#### 如果车and乘不能瞬移

则要求，第i-1轮乘客的终点=第i轮乘客的起点。

这样存在的问题是，如果乘客第i-1轮下了车之后，第i轮仍需打车，则会导致，车辆在第i轮的初始位置=第i-1轮乘客的目的地，且乘客第i轮的起点=第i-1轮乘客的目的地，即第i轮中，车辆的位置=乘客起点。

此时相当于乘客一抬手直接拉车门上车，则PickUp()的过程直接消失不见。

且此种情况对选点进行限制。
