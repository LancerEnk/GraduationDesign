# 如何获取真实的地图数据，并将其转化为区块链上可用的地图数据？

## 0 环境配置

笔者所有软件的安装环境均为Windows11系统。

涉及到的安装包、软件和地图数据占磁盘空间较大，因此如果Linux系统中存储空间不足，请谨慎在Linux中配置环境处理数据。

### 0.1 数据库 - PostgreSQL 和 PostGIS

本部分需安装的软件：PostgreSQL 和 PostGIS

* PostgreSQL：用于存放地图数据的数据库
* PostGIS：PostgreSQL对象关系数据库的空间数据库扩展器

安装参考如下：

* [安装参考1](https://blog.csdn.net/weixin_46014027/article/details/121035453?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168252119016800227459506%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168252119016800227459506&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-121035453-null-null.142^v86^insert_down1,239^v2^insert_chatgpt&utm_term=postgresql%E5%AE%89%E8%A3%85)
* [安装参考2](https://blog.csdn.net/ljg124034929/article/details/70142119)
* [安装参考3](https://blog.csdn.net/my1324/article/details/103226622)

此处需要注意一个点，即在 `安装参考1` 网页中，第10步安装完成的时候，需要勾选“Stack Builder”，这是安装PostGIS所需要的环节。

如果完全按照 `安装参考1` 做，不勾选“Stack Builder”的话，则在后续给数据库中添加PostGIS插件和pgRouting插件时，数据库将会报错 - 找不到这两个插件。

#### 数据库相关内容的版本

* postgreSQL：6.21
  * 笔者在6月份打开postgreSQL，发现其版本好像已经更新到7.x了，所以读者可酌情升级更新版本。

* PostGIS：3.3.2

* pgRouting：3.4.2

### 0.2 地图处理软件 - ArcGIS

本部分需安装的软件：ArcGIS 和 ArcGIS Editor for OSM。

* ArcGIS：用于shapefile类型地图数据的可视化和整体处理
* ArcGIS Editor for OSM：用于shapefile类型地图数据的裁剪

安装参考如下：

* [ArcGIS安装参考1](https://blog.csdn.net/lionhenryzxxy/article/details/112913398?ops_request_misc=&request_id=&biz_id=102&utm_term=arcgis%20desktop%20%E5%AE%89%E8%A3%85&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-112913398.142^v83^insert_down38,239^v2^insert_chatgpt)

* [ArcGIS Editor for OSM下载及安装参考](https://blog.csdn.net/qq_21126203/article/details/78734244)

在文章中有很明确的安装方法，因此笔者不多赘述。

#### 地图处理相关内容的版本

* ArcGIS：10.8
* ArcGIS Editor for OSM：10.8

## 1 数据下载

[道路数据获取方法](https://blog.csdn.net/u010065726/article/details/128485142?ops_request_misc=%7B%22request_id%22:%22168145055116800182128489%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168145055116800182128489&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-128485142-null-null.142%5Ev83%5Einsert_down38,239%5Ev2%5Einsert_chatgpt&utm_term=osm%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9D%90%E6%A0%87%E7%B3%BB)

按照上述文章，笔者的道路数据(.shp文件格式)在[Geofabrik Download Server](https://download.geofabrik.de/)中完成下载。

## 2 数据筛选

### 2.1 数据裁剪

**目的**：**删去无用的其他省市数据，减小地图范围，方便后续处理**

在 `Geofabrik Download Server` 中下载 `china-latest-free.shp` ，解压缩，用ArcGIS打开它。

按照北京的经纬度，在ArcGIS中对北京区域进行框选，选择北京的道路元素后，右键单击`当前图层`->选择`数据`->选择`导出数据`->导出所选元素，坐标系与此图层的源数据相同，选择输出要素类的存储位置，并把导出文件命名为`out1.shp`->`确定`。即完成当前经纬度下，数据的导出。

### 2.2 要素转线

**目的**：**把一整条道路，把它在它与其他道路的交叉点处打断，实现道路的分段效果。**

用ArcGIS打开`out1.shp`，选择图层里的所有数据，点击ArcToolBox，找：数据管理工具->要素转线，双击它。

```txt
输入要素：out1.shp
输出要素类：自行选择位置，修改命名为bjway
XY容差：不管
保留属性：选中，要保留属性
```

单击确定，等待它运行。

### 2.3 获取每节道路两端的经纬度

**目的**：**方便在数据库里筛选道路**

> 这一步有2种方式：1.ArcGIS中直接完成，数据库里就不用对此进行处理了。2.不在ArcGIS中完成，而在数据库里新建列通过函数完成。

**1**.**ArcGIS中直接完成**。（本文选择此种方法，本文后续内容也均以此处理方法为前提）

用ArcGIS打开`bjway.shp`，选择图层里的所有数据，点击ArcToolBox，找：数据管理工具->添加几何元素，双击它。

```txt
输入要素：bjway.shp
几何属性：选中LINE_START_MID_END
长度：Meters
面积：SquareMeters
坐标系：GCS_WGS_1984（WKID=4326的那个）
```

单击确定，等待它运行。

**2**.**在数据库里新建列通过函数完成**。（本文未选择此种方法）

在数据库中，由于geom存储着道路中点的经纬度，因此，可以直接通过解码geom获取该道路的首尾经纬度。

使用如下语句：

```sql
-- ST_PointN()是获取第n个点的经纬度，下述语句能获取道路首、末点的经纬度（根据geometry格式的geom进行解析）
-- 应该可以用这个东西来解决经纬度的范围，用其他语句增添x1、y1、x2、y2四个列，存储道路的首尾端点经纬度信息
select name,gid,ST_x(ST_PointN(geom, 1)),ST_y(ST_PointN(geom, 1)),ST_x(ST_PointN(geom, ST_NumPoints(geom))),ST_y(ST_PointN(geom, ST_NumPoints(geom))),st_astext(geom),geom from bjway limit 100; 
```

### 2.4 导入到数据库中

**目的**：**将最终得到的文件bjway.shp导入postgreSQL中。**

[导入参考](https://zhuanlan.zhihu.com/p/121602526)

按照`导入参考`中`二、将数据导入数据库`的步骤依次完成，需注意的地方为：应添加`bjway.shp`，且应修改为`SRID=4326`，点击Import，数据导入成功。

此时打开数据库，使用下列语句查询是否成功导入数据，是否有start_x/start_y/mid_x/mid_y/end_x/end_y这几个新加入的数据。

```sql
-- 查询表中内容是否正常
select * from bjway;
```

### 2.5 初步处理数据

**目的**：**为道路数据添加cost，并创建道路拓扑**

大体思路是按照[导入参考](https://zhuanlan.zhihu.com/p/121602526)中`三、设置路径成本并建立路网拓扑`做的，但是它的某些语句不适合我们直接使用。

按照以下语句依次完成即可。

```sql
-- 为道路增加cost、reverse_cost、source、target字段
ALTER TABLE bjway
ADD COLUMN source INTEGER,
ADD COLUMN target INTEGER,
ADD COLUMN cost DOUBLE PRECISION,
ADD COLUMN reverse_cost DOUBLE PRECISION;
-- 成功，但是一个激动把postgresql关了...可以通过下述语句查看这四列是否正常产生
select * from bjway；

--计算正向成本
UPDATE bjway
SET cost = st_length(ST_GeographyFromText(st_astext(geom))), reverse_cost = -1
WHERE oneway = 'F';
-- 是数据库闪退了？？？重新打开，查询一下cost是否正常生成
select gid,name,cost,reverse_cost,source,target,st_astext(geom) as l from bjway where oneway = 'F'

-- 计算逆向成本
UPDATE bjway
SET reverse_cost = st_length(ST_GeographyFromText(st_astext(geom))), cost = -1
WHERE oneway = 'T';
select gid,name,cost,reverse_cost,source,target,st_astext(geom) as l from bjway where oneway = 'T';
-- reverse_cost正常生成

-- 计算双向成本
UPDATE bjway
SET cost = st_length(ST_GeographyFromText(st_astext(geom))), reverse_cost = st_length(ST_GeographyFromText(st_astext(geom)))
WHERE oneway = 'B';
select gid,name,cost,reverse_cost,source,target,st_astext(geom) as l from bjway where oneway = 'B';
-- 双向道路的cost和reverse_cost都正常生成

-- 创建拓扑
SELECT pgr_createTopology('bjway', 0.001,'geom','gid','source','target'); 
-- 花了3min，查询后，有正常的返回结果
select gid,name,cost,reverse_cost,source,target,st_astext(geom) as l from bjway;
```

## 3 数据导出

**目的**：**从数据库中导出地图原始数据**

在数据库中，通过select语句完成数据查询，并且直接导出：

如果想要修改地理位置范围，需要修改start_x和start_y的上下限；如果想要修改道路类型，需要修改code和oneway。

```sql
-- 大地图
SELECT
  array_to_json(array_agg(row_to_json(ff)))
FROM
  (SELECT
    ( SELECT row_to_json(t) FROM
      ( select minzoom, fclass as highway, round(cost::numeric,0) as cost, gid, name, source, target, one_way as oneway ) 
      AS t 
    ) AS properties ,
    ST_AsGeoJSON(geom)::json AS geometry,
    'Feature' AS type 
  FROM bjway
  WHERE
    ((code = 5112 or code = 5113 or code = 5114 or code = 5115 or code = 5132 or code = 5133 or code = 5134 or code = 5135) and (start_x between 116.279 and 116.367) and (start_y between 39.903 and 39.991) and oneway = 'F') 
  order by gid) 
AS ff;
```

输入此语句完成查询后，单击查询结果，对其直接复制即可。

## 4 脚本处理

新建一个i.json文件，里面放置如下内容：

```json
{"crs":{"properties":{"name":"urn:ogc:def:crs:EPSG::4326"},"type":"name"},"features":}
```

将`3 数据导出`中复制到的内容，粘贴在`"features":`后。完成粘贴后的数据如下例：

```json
{"crs":{"properties":{"name":"urn:ogc:def:crs:EPSG::4326"},"type":"name"},"features":[{"properties":{"minzoom":7,"highway":"tertiary","cost":275,"gid":77922,"name":"北蜂窝路","source":14360,"target":13987,"oneway":"yes"},"geometry":{"type":"LineString","coordinates":[[116.3227718,39.9037387],[116.3227968,39.9012597]]},"type":"Feature"}]}
```

修改`geojson_2_geohashjson-china_border.js`中的内容为：

```js
//···
var gname = './o.json';
//···
var map_file="./i.json";
//···
```

在terminal里运行`geojson_2_geohashjson-china_border.js`：

```shell
node geojson_2_geohashjson-china_border.js
```

运行完毕后，获得`o.json`。

## 5 上传地图

将`o.json`移至原来地图的存放目录，在`uploadmap_cjz_3.js`中修改代码：

```js
var map_file = "./o.json";
```

向已打开的区块链中上传地图，用vehicle_test.py和passenger_test.py进行测试，查看地图的显示效果和运行效果。
